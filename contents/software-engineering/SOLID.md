# SOLID 원칙

## SOLID 원칙이란?
> 컴퓨터 프로그래밍에서 `객체 지향 프로그래밍` 및 설계의 `다섯가지 기본 원칙`으로, 시간이 지나도 `유지 보수`와 `확장`이 쉬운 시스템을 만들고자 할 때 적용 시킨다.
- SOLID 원칙들은 소프트웨어 작업에서 프로그래머가 소스 코드가 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩토링하여 `코드 스멜`을 제거하기 위해 적용할 수 있다.   
`코드 스멜`: 문제를 일으킬 가능성이 있는 소스 코드의 특징
- 애자일 소프트웨어 개발과 적응적 소프트웨어 개발의 전반적 전략의 일부이다.

<br>

## SOLID의 5가지 원리

### 1. SRP(단일 책임 원칙, Single Responsibility Principle)

<b> 정의 </b>
> 소프트웨어 설계 부품(클래스, 메소드)는 하나의 책임(기능)만 가져야 한다.
- SRP 원리를 적용하면 책임 영역이 확실해지기 때문에, 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용으로부터 자유로울 수 있다.
- 책임을 적절히 분배함으로써 코드의 가독성이 향상되고 유지보수가 용이해진다.

<b> 적용 방법 </b>

- 각 책임을 각각의 개별 클래스(함수)로 분할하여 클래스 당 하나의 책임만을 맡도록 한다.
- 책임만 분리하는 것이 아니라 분리된 두 클래스 간 관계의 복잡도를 줄이도록 설계한다.

<b> 적용 이슈 </b>

- 클래스 이름은 해당 클래스의 책임을 나타낼 수 있도록 하는 것이 좋다.
- 각 클래스는 하나의 개념을 나타내어야 한다.
- 무조건 책임을 분리한다고 SRP가 적용되는 것은 아니다.

### 2. OCP(개방-폐쇄 원칙, Open/Closed Principle)

<b> 정의 </b>
> 기존의 코드를 변경하지 않고(Closed) 기능을 수정하거나 추가할 수 있도록(Open) 설계해야 한다.
- 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고 변경에는 닫혀있어야 한다.
- 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화 해야 한다.
- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다.
- OCP는 객체 지향의 장점을 극대화하는 아주 중요한 원리이다.

<b> 적용 방법 </b>

- 변경(확장)될 것과 변하지 않을 것을 엄격히 구분한다.
- 두 모듈이 만나는 지점에 인터페이스를 정의한다.
- 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성한다.

<b> 적용 이슈 </b>

- 확장되는 것과 변경되지 않는 모듈을 분리하는 과정에서 크기 조절에 실패하면 관계가 더 복잡해질 수 있다.
- 인터페이스는 가능하면 변경되어서는 안된다.
- 인터페이스 설계에서 적당한 추상화 레벨을 선택해야 한다.

### 3. LSP(리스코프 치환 원칙, Liskov Substitution Principle)

<b> 정의 </b>
> 자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다.
- 부모 클래스와 자식 클래스 사이의 행위에는 일관성이 있어야 한다.
- 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 문제가 없어야 한다.
- 상속 관계에서는 일반화 관계(IS-A)가 성립해야 한다.   
-> 일반화 관계가 성립한다 = 일관성이 있다

<b> 적용 방법 </b>

- 만약 두 개체가 똑같은 일을 한다면 둘을 하나의 클래스로 표현하고 이들을 구분할 수 있는 필드를 둔다.
- 똑같은 연산을 제공하지만, 이들을 약간씩 다르게 한다면 공통의 인터페이스를 만들고 각각 구현한다.(인터페이스 상속)
- 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만든다.
- 만약 두 개체가 하는 일에 추가적으로 무언가를 더 한다면 구현 상속을 사용한다.

<b> 적용 이슈 </b>

- 혼동될 여지가 없다면 그대로 둔다.

### 4. ISP(인터페이스 분리 원칙, Interface Segregation Principle)

<b> 정의 </b>
> 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.
- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
- 어떤 클래스를 사용하는 클라이언트가 여러 개고 이들이 해당 클래스의 특정 부분집합만을 이용한다면, 이들을 따로 인터페이스로 빼내야 한다.

<b> 적용 방법 </b>

- 클래스의 상속을 이용하여 인터페이스를 나눌 수 있다.
- 위임(Delegation)을 이용하여 인터페이스를 나눌 수 있다.

<b> 적용 이슈 </b>

- 클라이언트에 변경을 주지 말아야 한다.
- 두 개 이상의 인터페이스가 공유하는 부분의 재사용을 극대화 해야 한다.
- 서로 다른 성격의 인터페이스를 명백히 분리 한다.

### 5. DIP(의존관계 역전 원칙, Dependency Inversion Principle)

<b> 정의 </b>
> 프로그래머는 추상화(변화하기 어려운 것)에 의존해야지, 구체화(변화하기 쉬운 것)에 의존하면 안된다.
- 여기서의 역전은 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전이다.

<b> 적용 방법 </b>

- Layering   
추상화 통해 상위 모듈은 하위 모듈로의 의존성에서 벗어나 그 자체로 사용되고 확장성도 보장 받을 수 있다.
<img src="images/SOLID/Layering.png"/>

<br>

---
## Reference

<a href="https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)">SOLID (객체 지향 설계)</a>

<a href="https://www.nextree.co.kr/p6960/">객체지향 개발 5대 원리: SOLID</a>

<a href="https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99">SOLID 원칙</a>